# DASH-Admin 二次开发教程与规范

##  命名规范
###  文件命名
- 模型文件: xxx_model.py
- 服务文件: xxx_service.py
- 视图文件: xxx.py
- 回调文件: xxx_c.py

###  类命名
- 模型类: XxxModel
- 服务类: XxxService

###  数据库模型字段命名
- 字段名: 小写字母+下划线
- 字段类型: 与业务相关的类型
- 字段注释: 字段的业务含义
 必须包含
- `id`: 主键ID / `name`: 名称 / `status`: 状态（True-正常, False-禁用） / `del_flag`: 删除标志（True-已删除, False-正常） / `create_by`: 创建者ID / `create_time`: 创建时间 / `update_by`: 更新者ID / `update_time`: 更新时间 / `description`: 描述 / `remark`: 备注

##  数据范围
系统设计为: 以部门为数据范围边界,如需数据范围过滤,需要数据库表和部门表外键关联,和部门多对一关系,可以在模型类中添加外键关联,在查询时自动过滤
如果数据表和部门表多对多关系,需要在数据服务类手动数据范围过滤,


## 一、 路由注册
路由配置位于 `/config/router_config.py`，支持三种菜单注册方式。
- 路由系统使用`RouterConfig`类统一管理路由配置,
- 配置好后,自动生成侧边导航菜单,数据库页面信息,数据库权限字符和页面关联,访问 URL 后自动鉴权是否有权访问,自动返回对应的页面元素渲染
### 1.1 新增一级菜单
```python
# config/router_config.py
class RouterConfig:
# 核心页面侧边菜单完整结构
    core_side_menu: List[Dict[str, Any]] = [


        {
            "component": "Item",
            "props": {
                "title": "测试页面",
                "key": "/test",            # 路由 key 唯一，且以 / 开头
                "icon": "antd-home",    # 图标可使用 Ant Design 图标（fac 封装）
                "href": "/test",             # 与 key 一致，唯一
                "view": "views.test.render",  # 页面视图函数导入路径，xxx.xxx 对应 views/xxx/xxx.py
                "page_type": "standard",     # 页面类型,标准页面,独立渲染页面,公共页面 , 公共渲染不会权限校验都能访问
                "show_sidebar": True,       # TRUE 根据权限渲染侧边栏导航菜单,默认True, 对于公共页面可以选择false,不渲染侧边栏
            },
        },


    ]
```

### 1.2 新增二级子菜单
```python
# config/router_config.py
ROUTER_CONFIG = [
    # 找到父菜单配置，在children中添加
    {   
        "component": "SubMenu",
        "props": {
            "key": "/project",
            "title": "项目管理",
            "icon": "antd-home",
        },
        "children": [
            {
            "component": "Item",
            "props": {
                "title": "项目管理",
                "key": "/project/project",            # 路由key 唯一  增加父级key 为前缀
                "icon": "antd-home",           # 图标 可以使用 fac 官网图标库
                "href": "/project/project",            # 与 key 一致，唯一
                "view": "views.project.project.render",  # 页面视图函数导入路径，xxx.xxx 对应 views/xxx/xxx.py
                "page_type": "standard",     # 页面类型,标准页面,独立渲染页面,公共页面 , 公共渲染不会权限校验都能访问
                "show_sidebar": True,       # 是否渲染到侧边栏导航菜单, 对于公共页面可以选择false
            },
        },

        ]
    },
]
```

### 1.3 添加到现有菜单下
与1.2类似，找到对应的父菜单节点，在其children数组中添加新的子菜单配置。


### 现在可以启动项目，看看配置页面和侧边栏菜单是否正常显示
```bash
python app.py
```

## 二、 网页文件结构

### 1.视图页面创建
页面文件统一放置于 `/views/` 目录下，根据功能模块创建对应文件。
#### 1.1 创建页面示例
```python
# views/project/project.py
from dash import html
import feffery_antd_components as fac
from callbacks.project_c import project_c

def render(*args, **kwargs):
    """
    项目管理页视图函数
    返回包含基础布局的 HTML 结构
    """
    return html.Div(
        [
            html.P("这是新增加的 项目管理页面"),
            fac.AntdButton('测试按钮', id='button-basic-event'),
            fac.AntdText(id='button-basic-event-output'),

        ]
    )

# 页面回调(详见回调层开发章节)
```
#### 1.2 前端页面根据权限渲染页面元素示例
```python
# views/project/project.py
from dash import html
import feffery_antd_components as fac
from flask_login import current_user

# 根据是否有 访问权限 控制页面整体渲染
def render(*args, **kwargs):
    """
    项目管理页视图函数
    返回包含基础布局的 HTML 结构
    """
    return html.Div(
        [
            html.P("这是新增加的项目管理页面"),
            html.H1(f"有查询权限") if current_user.check_permission("test:query") else html.H1(f"没有查询权限"),
        ]
    )
```

### 2. 回调层开发
回调函数统一放置于 `/callbacks/` 目录下。

#### 1 回调实现示例
```python
# callbacks/project_c/project_c.py
from dash import Input, Output, State, callback, no_update
from server import app,current_user

@app.callback(
    Output('button-basic-event-output', 'children'),
    Input('button-basic-event', 'nClicks'),
    prevent_initial_call=True,
)
def button_basic_event(nClicks):
    return f'点击了按钮: {nClicks}'


```
### 3. 页面导入到 初始化文件 `/views/__init__.py` 

作用：在启动时加载注册所有页面，避免页面注册不完整导致回调函数无法触发
```python
# views/__init__.py
from . import index
from .system import sys_user,sys_dept,sys_post,sys_role,sys_permissions,sys_log
from .project import project

__all__ =(
    "index",
    "sys_user",
    "sys_dept",
    "sys_post",
    "sys_role",
    "sys_permissions",
    "sys_log",
    "project"
)
```


## 三、 数据库模型设计
### 1 模型基类说明
项目提供了基础模型类 `BaseCrud`，位于 `/models/base_crud.py`，已包含以下公共字段：
- `dept_id`: 部门ID
- `status`: 状态（True-正常, False-禁用）
- `del_flag`: 删除标志（True-已删除, False-正常）
- `create_by`: 创建者ID
- `create_time`: 创建时间
- `update_by`: 更新者ID
- `update_time`: 更新时间
- `description`: 描述
- `remark`: 备注
-
-
-
如果和部门是多对多关系可以继承`BaseMixin` 里面不包含 `dept_id`字段,手动校验数据范围

-
-
-

### 2 模型创建规范
#### 2.1 单表模型(继承基类BaseCrud)
**多对一关系**(适用于归属单个部门的实体):
```python
# models/project/project_model.py
from models.base import Base
from models.base_crud import BaseCrud
from sqlalchemy import Integer, String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from models.system.dept.dept_model import DeptModel
class ProjectModel(Base,BaseCrud):
    __tablename__ = "project"
    # 主键
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True, comment='ID')

    # 项目信息字段
    name: Mapped[str] = mapped_column(String(50), nullable=False, comment='项目名称')
    code: Mapped[str] = mapped_column(String(64), unique=True,nullable=False, comment='项目编码')
    # 关联关系
    # 项目与部门的关联关系
    dept: Mapped['DeptModel'] = relationship(
        'DeptModel',
        back_populates='project_list',
        lazy='selectin'
    )
```
对应的 DeptModel 模型类需要包含 `project_list` 字段，用于反向关联。
```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from models.project.project_model import ProjectModel
class DeptModel(Base,BaseMixin):
    __tablename__ = "sys_dept"
    # 主键
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True, comment='ID')

    # 部门信息字段
    ......

    # 部门下的项目列表
    project_list: Mapped[list["ProjectModel"]] = relationship(
        "ProjectModel",
        back_populates="dept", 
        lazy="selectin" )
```

#### 2.2 多对多模型(继承基类BaseMixin)
**多对多关系**(适用于归属多个部门的实体):
```python
# 2. 在模型中定义关系 - models/project/project_model.py
from models.base import Base
from models.base_crud import BaseMixin
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from models.system.dept.dept_model import DeptModel

# 项目表和部门表的 中间关联表
project_dept_rel = Table(
    "project_to_dept",
    Base.metadata,
    Column("project_id", Integer, ForeignKey("project.id"), primary_key=True),
    Column("dept_id", Integer, ForeignKey("sys_dept.id"), primary_key=True)

    )

# 项目表模型
class ProjectModel(Base,BaseMixin):
    __tablename__ = "project"
    
     # 主键
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True, comment='ID')

    # 项目信息字段
    name: Mapped[str] = mapped_column(String(50), nullable=False, comment='项目名称')
    code: Mapped[str] = mapped_column(String(64), unique=True,nullable=False, comment='项目编码')
    # 其他业务字段...
     # 当前项目关联部门
    dept_list: Mapped[list["DeptModel"]] = relationship(

        secondary=project_dept_rel,
        back_populates="project_list",
        lazy="selectin",
    )
    # 其他业务字段...

```
对应的 DeptModel 模型类需要包含 `project_list` 字段，用于反向关联。
```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from models.project.project_model import ProjectModel

class DeptModel(Base,BaseMixin):
    __tablename__ = "sys_dept"
    # 主键
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True, comment='ID')

    # 部门信息字段
    ......

    # 部门关联项目
    project_list: Mapped[list["ProjectModel"]] = relationship(
        secondary="project_to_dept",  # 关联表的数据库名称字符, 不是模型类名
        back_populates="dept_list",
        lazy="selectin",
    )
```
### 3.导入模型 到数据库 初始文件 位于 `/models/__init__.py`
1.导入项目模块下模型文件 到 项目初始文件
```python
# models/project/__init__.py
from .project_model import ProjectModel
```
2.导入项目下模型 数据库初始文件

```python
# models/__init__.py
from .system import *
from .project import *
```
3.你亦可以直接导入到 数据库初始文件

```python
# models/__init__.py
from .project.project_model import ProjectModel
```

### 4. 服务类实现
服务类需继承自基础服务类 `BaseService`，位于 `/models/base_service.py`

#### 1 基础服务类实现(多对一关系)
***(适用于属于单部门范围内)***
服务基类已经实现了 多对一的 通用增删改查,根据字段查询所有,分页查询所有等,
自动过滤角色数据范围,和操作权限校验. 也可以根据需求重构
```python
# models/project/project_service.py
from sqlalchemy.orm import Session
from models.base_service import BaseService
from .project_model import ProjectModel

class ProjectService(BaseService[ProjectModel]):
    def __init__(self, db: Session, current_user_id:int):
        super().__init__(model=ProjectModel, db=db, current_user_id=current_user_id)



```
#### 2 基础服务类实现(多对多 关系)

***(适用于属于多部门范围,和部门多对多关系)***
多对多 需要手动验证判断 关联关系字段和  关联部门字段
```python
# models/project/project_service.py
from models.base_service import BaseService
from .project_model import ProjectModel


class ProjectService(BaseService[ProjectModel]):
    def __init__(self, db: Session, current_user_id: int):
        super().__init__(db=db, model=ProjectModel, current_user_id=current_user_id)
    
    def create(self, **kwargs) -> ProjectModel:
        """
        创建项目

        参数:
            **kwargs: 项目字段字典

        返回:
            项目对象
        """
        if "dept_id" not in kwargs:
            raise ValueError("部门ID 字段无效或者未传入")
        if "dept_id" in kwargs:
            dept_id = kwargs.get("dept_id", None)
            if dept_id is None:
                raise ValueError("部门ID不能为空")
            dept_id = [int(d) for d in dept_id]

            """ 判断当前项目是归属部门否在 当前用户范围内 """
            if not self.check_dept_ids_in_data_scope(set(dept_id)):
                raise PermissionError("您权限不足，部门不在权限范围内")

        """获取部门 """
        dept_service = DeptService(db=self.db, current_user_id=self.current_user_id)
        depts, _ = dept_service.get_all_by_fields(id=dept_id)
        if not depts:
            raise ValueError("部门不存在")

        kwargs.pop("dept_id")
        project = super().create(**kwargs)
        project.dept_list = depts
        return project

    def update(self, obj_id: int, **kwargs) -> ProjectModel:
        """
        更新项目

        参数:
            obj_id: 项目ID
            **kwargs: 项目字段字典

        返回:
            项目对象
        """
        if "dept_id" not in kwargs:
            raise ValueError("部门ID 字段无效或者未传入")
        if "dept_id" in kwargs:
            dept_id = kwargs.get("dept_id", None)
            if dept_id is None:
                raise ValueError("部门ID不能为空")
            dept_id = [int(d) for d in dept_id]
            """ 判断当前角色是否在 当前用户范围内 """
            if not self.check_dept_ids_in_data_scope(set(dept_id)):
                raise PermissionError("您权限不足，部门不在权限范围内")

        """获取部门 """
        dept_service = DeptService(db=self.db, current_user_id=self.current_user_id)
        depts, _ = dept_service.get_all_by_fields(id=dept_id)
        if not depts:
            raise ValueError("部门不存在")

        kwargs.pop("dept_id")
        project = super().update(obj_id=obj_id, **kwargs)
        project.dept_list = depts
        return project
```



## 四、 权限配置
权限配置需在 `config/permission_config.py` 中添加，使用数据库模型名称作为权限标识。

### 4.1 权限配置示例
```python
# config/permission_config.py
class permissionConfig:
    """
        数据操作权限配置-增删改查数据库的时候 会校验当前用户 对应当前数据表的操作权限,
        其余权限可以自己定义校验规则
    """

     # 配置数据库表模型类名称后 默认添加 访问,查询,新增,编辑,删除,导入,导出 字符权限,
    modules = [
        {"module_key": "user", "module_name": "用户"},
        {"module_key": "role", "module_name": "角色"},
        {"module_key": "post", "module_name": "岗位"},
        {"module_key": "dept", "module_name": "部门"},
        {"module_key": "project", "module_name": "项目"},  # 添加数据库表模型类对应名称,如 UserModel  ,只需要user即可,前缀且为小写
    ]
    """
         如需自定义配置权限 可以使用以下方法
         对于数据库操作的需要对应数据库模型类 名称
         对于自定义权限 可以自己在需要验证的时候校验
     # 
    """
    # 自定义配置权限
    permissions["permissions"] = [
        {"key": f"permissions:{OperationType.QUERY.code}", "name": f"权限字符:{OperationType.QUERY.description}"},
    ]
    permissions["log"]= [
        {"key": f"log:{OperationType.QUERY.code}", "name": f"日志:{OperationType.QUERY.description}"},
    ]
```
## 五、数据库迁移，启动应用
### 1. 创建数据库迁移文件
```bash
alembic revision --autogenerate -m "添加项目表"

```
### 2. 应用迁移
```bash
alembic upgrade head
```
### 3. 启动应用
```bash
python app.py
```
### 4. 访问项目
```bash
打开浏览器访问: http://127.0.0.1:8050
```


